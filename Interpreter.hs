{-# LANGUAGE TemplateHaskell #-}
module Interpreter where

import Bound
import Bound.Scope
import Control.Applicative
import Control.Lens
import Control.Monad.Except
import Control.Monad.State
import Data.List
import Data.Map (Map)
import qualified Data.Map as M
import Data.Monoid
import Lam

-- This module is an interpreter for the Lam language, but one that simulates
-- the behavior of the STG program for the expression it interprets.

type STG = StateT STGState (Except [String])
type STGProgram = STG (Int, [Closure])

data Closure =
  Closure {
    _enter :: STGProgram,
    _fields :: [Closure]
  }

instance Show Closure where
  show (Closure _ vs) = "Closure _ " ++ show vs

data STGState =
  STGState {
    _curClosure :: Closure,
    _argstack :: [Closure],
    _callstack :: [Map Name Closure]
  }

makeLenses ''Closure
makeLenses ''STGState

startState :: STGState
startState = STGState emptyClos [] [M.empty]
  where emptyClos = Closure (return (0, [])) []

liftMay :: MonadError e m => e -> Maybe a -> m a
liftMay e Nothing = throwError e
liftMay e (Just a) = return a

pop :: Monad m => ALens' s [a] -> StateT s m (Maybe a)
pop l = zoom (cloneLens l) (state doPop)
  where doPop [] = (Nothing, [])
        doPop (a:as) = (Just a, as)

popFail :: MonadError e m => e -> ALens' s [a] -> StateT s m a
popFail e l = pop l >>= liftMay e

data Ix = Local Name | Closed Int deriving (Show, Eq, Ord)

resolve :: Ix -> STG Closure
resolve v = preuse l >>= liftMay err
  where l = case v of
          Local name -> callstack._head.ix name
          Closed i -> curClosure.fields.ix i
        err = ["nonexistent variable " ++ show v]

closure :: Lam Ix -> STG Closure
closure l = do
  let (l', free) = runState (traverse (state . replace) l) []
      replace v seen = case findIndex (==v) seen of
        Nothing -> (Closed (length seen), seen ++ [v])
        Just i  -> (Closed i, seen)
  vs <- traverse resolve free
  return (Closure (run l') vs)

result :: a -> STG a
result a = a <$ popFail err callstack
  where err = ["tried to return with empty callstack"]

call :: Lam Ix -> STGProgram
call l = callstack %= dup >> run l
  where dup [] = []; dup (f:fs) = f:f:fs

run :: Lam Ix -> STGProgram
run (Var v) = do
  clos <- resolve v
  -- this needs to be reset on return
  curClosure .= clos
  callstack._head .= M.empty
  _enter clos
run (Abs name b) = do
  let b' = instantiate1 (Var (Local name)) b
      -- ^ This is OK as long as our source term is generated by parsing a
      -- concrete term, since we're basically just transferring the original
      -- concrete scopes into concrete scopes in the target language.
      err = ["tried to apply function with no args"]
  arg <- popFail err argstack
  callstack._head.at name .= Just arg
  run b'
run (App f x) = do
  arg <- closure x
  argstack %= (arg:)
  run f
run (Lit i) = result (i, [])
run (Op o x y) = do
  (xv, _) <- call x
  (yv, _) <- call y
  let val = case o of
        Add -> xv + yv
        Sub -> xv - yv
        Eq  -> hashCode (Name (show (xv == yv)))
        Leq -> hashCode (Name (show (xv <= yv)))
  result (val, [])
run (Ctor name fs) = do
  thunks <- traverse closure fs
  result (hashCode name, thunks)
run (Case x cs) = do
  (ctor, vs) <- call x
  let clause = find (\(Clause n _ _) -> hashCode n == ctor) cs
      err = ["no clause matching " ++ show ctor]
  Clause name names b <- liftMay err clause
  let err = ["pattern has " ++ show (length names) ++ " bindings;" ++
             "constructor has " ++ show (length vs) ++ " fields"]
  unless (length names == length vs) (throwError err)
  let b' = instantiateVars (map Local names) b
      env' = M.fromList (zip names vs)
  callstack._head %= M.union env'
  run b'

